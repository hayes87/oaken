#version 450

// Forward+ Light Culling Compute Shader
// Simple conservative tile-based light culling

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#define TILE_SIZE 16
#define MAX_LIGHTS_PER_TILE 256
#define MAX_POINT_LIGHTS 1024

struct PointLight {
    vec4 positionRadius;  // xyz = position, w = radius
    vec4 colorIntensity;  // rgb = color, w = intensity
};

// Input: Depth buffer (unused in simple version)
layout(set = 0, binding = 0) uniform sampler2D depthTexture;

// Input: Light data
layout(std430, set = 0, binding = 1) readonly buffer LightBuffer {
    int numLights;
    int _pad0;
    int _pad1;
    int _pad2;
    PointLight lights[MAX_POINT_LIGHTS];
} lightBuffer;

// Output: Per-tile light indices
layout(std430, set = 1, binding = 0) writeonly buffer TileLightIndices {
    uint data[];
} tileLightIndices;

// View/Projection matrices
layout(std140, set = 2, binding = 0) uniform ViewData {
    mat4 view;
    mat4 proj;
    mat4 invProj;
    vec4 screenSize;  // xy = size, zw = 1/size
} viewData;

shared uint sharedLightCount;
shared uint sharedLightIndices[MAX_LIGHTS_PER_TILE];

// Simple sphere-tile intersection test in clip/screen space
bool sphereIntersectsTile(vec3 lightPosView, float radius, vec2 tileMin, vec2 tileMax, vec2 screenSize) {
    // If light is completely behind camera, skip
    if (lightPosView.z > radius) {
        return false;
    }
    
    // If light sphere crosses the camera plane, be conservative - include in all tiles
    if (lightPosView.z > -radius) {
        return true;
    }
    
    // Project light center to screen
    vec4 clipPos = viewData.proj * vec4(lightPosView, 1.0);
    vec2 ndc = clipPos.xy / clipPos.w;
    
    // Convert to screen coordinates (Vulkan Y-flip)
    vec2 screenPos;
    screenPos.x = (ndc.x * 0.5 + 0.5) * screenSize.x;
    screenPos.y = (-ndc.y * 0.5 + 0.5) * screenSize.y;
    
    // Estimate screen-space radius (conservative)
    // Use the closest point of the sphere for maximum screen size
    float closestZ = max(-lightPosView.z - radius, 0.1);
    vec4 radiusClip = viewData.proj * vec4(radius, 0.0, -closestZ, 1.0);
    float screenRadius = abs(radiusClip.x / radiusClip.w) * screenSize.x * 0.5;
    
    // Add generous padding
    screenRadius += float(TILE_SIZE) * 3.0;
    
    // Circle-AABB intersection test
    vec2 closest = clamp(screenPos, tileMin, tileMax);
    vec2 diff = screenPos - closest;
    float distSq = dot(diff, diff);
    
    return distSq <= screenRadius * screenRadius;
}

void main() {
    uvec2 tileId = gl_WorkGroupID.xy;
    uint localIndex = gl_LocalInvocationID.y * TILE_SIZE + gl_LocalInvocationID.x;
    
    // Initialize shared memory
    if (localIndex == 0) {
        sharedLightCount = 0;
    }
    barrier();
    
    // Calculate tile bounds
    ivec2 screenSize = ivec2(viewData.screenSize.xy);
    vec2 tileMin = vec2(tileId) * float(TILE_SIZE);
    vec2 tileMax = min(tileMin + float(TILE_SIZE), vec2(screenSize));
    
    // SIMPLE APPROACH: Just add all lights to all tiles (no culling)
    // This is inefficient but should work correctly
    uint numLights = uint(lightBuffer.numLights);
    
    // Each thread adds one light
    if (localIndex < numLights && localIndex < MAX_LIGHTS_PER_TILE) {
        uint index = atomicAdd(sharedLightCount, 1);
        if (index < MAX_LIGHTS_PER_TILE) {
            sharedLightIndices[index] = localIndex;
        }
    }
    barrier();
    
    // Write results
    // CRITICAL: Use uint for all tile calculations to match fragment shader exactly
    uint screenWidthU = uint(viewData.screenSize.x);
    uint numTilesX = (screenWidthU + uint(TILE_SIZE) - 1u) / uint(TILE_SIZE);
    uint tileIndex = tileId.y * numTilesX + tileId.x;
    uint tileOffset = tileIndex * (MAX_LIGHTS_PER_TILE + 1);
    
    if (localIndex == 0) {
        tileLightIndices.data[tileOffset] = min(sharedLightCount, MAX_LIGHTS_PER_TILE);
    }
    
    uint lightCount = min(sharedLightCount, MAX_LIGHTS_PER_TILE);
    for (uint i = localIndex; i < lightCount; i += 256) {
        tileLightIndices.data[tileOffset + 1 + i] = sharedLightIndices[i];
    }
}
